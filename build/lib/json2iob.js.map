{
  "version": 3,
  "sources": ["../../src/lib/json2iob.ts"],
  "sourcesContent": ["//v1.5\n/*\noptions:\nwrite //set common write variable to true\nforceIndex //instead of trying to find names for array entries, use the index as the name\nchannelName //set name of the root channel\npreferedArrayName //set key to use this as an array entry name\nautoCast (true false) // make JSON.parse to parse numbers correctly\ndescriptions: Object of names for state keys\n*/\nimport JSONbig from \"json-bigint\";\n({ storeAsString: true });\nexport default class Json2iob {\n  adapter: any;\n  alreadyCreatedObjects: any;\n  constructor(adapter: any) {\n    this.adapter = adapter;\n    this.alreadyCreatedObjects = {};\n  }\n\n  async parse(\n    path: string,\n    element: string | null | undefined,\n    options?: {\n      [x: string]: any;\n      write?: any;\n      channelName?: any;\n      autoCast?: any;\n      descriptions?: any;\n      preferedArrayName?: any;\n      forceIndex?: any;\n    },\n  ): Promise<void> {\n    try {\n      if (element === null || element === undefined) {\n        this.adapter.log.debug(\"Cannot extract empty: \" + path);\n        return;\n      }\n\n      const objectKeys = Object.keys(element);\n\n      if (!options || !options.write) {\n        if (!options) {\n          options = { write: false };\n        } else {\n          options[\"write\"] = false;\n        }\n      }\n\n      if (typeof element === \"string\" || typeof element === \"number\") {\n        let name = element;\n        if (typeof element === \"number\") {\n          name = element.toString();\n        }\n        if (!this.alreadyCreatedObjects[path]) {\n          await this.adapter\n            .setObjectNotExistsAsync(path, {\n              type: \"state\",\n              common: {\n                name: name,\n                role: this.getRole(element, options.write),\n                type: element !== null ? typeof element : \"mixed\",\n                write: options.write,\n                read: true,\n              },\n              native: {},\n            })\n            .then(() => {\n              // this.alreadyCreatedObjects[path] = true;\n            })\n            .catch((error: any) => {\n              this.adapter.log.error(error);\n            });\n        }\n\n        this.adapter.setState(path, element, true);\n\n        return;\n      }\n      if (!this.alreadyCreatedObjects[path]) {\n        await this.adapter\n          .setObjectNotExistsAsync(path, {\n            type: \"channel\",\n            common: {\n              name: options.channelName || \"\",\n              write: false,\n              read: true,\n            },\n            native: {},\n          })\n          .then(() => {\n            // this.alreadyCreatedObjects[path] = true;\n            options.channelName = undefined;\n          })\n          .catch((error: any) => {\n            this.adapter.log.error(error);\n          });\n      }\n      if (Array.isArray(element)) {\n        await this.extractArray(element, \"\", path, options);\n        return;\n      }\n\n      for (const key of objectKeys) {\n        if (this.isJsonString(element[key]) && options.autoCast) {\n          element[key] = JSONbig({ storeAsString: true }).parse(element[key]);\n        }\n\n        if (Array.isArray(element[key])) {\n          await this.extractArray(element, key, path, options);\n        } else if (element[key] !== null && typeof element[key] === \"object\") {\n          await this.parse(path + \".\" + key, element[key], options);\n        } else {\n          if (!this.alreadyCreatedObjects[path + \".\" + key]) {\n            let objectName = key;\n            if (options.descriptions && options.descriptions[key]) {\n              objectName = options.descriptions[key];\n            }\n            const type = element[key] !== null ? typeof element[key] : \"mixed\";\n            const common = {\n              name: objectName,\n              role: this.getRole(element[key], options.write),\n              type: type,\n              write: options.write,\n              read: true,\n            };\n\n            await this.adapter\n              .setObjectNotExistsAsync(path + \".\" + key, {\n                type: \"state\",\n                common: common,\n                native: {},\n              })\n              .then(() => {\n                // this.alreadyCreatedObjects[path + \".\" + key] = true;\n              })\n              .catch((error: any) => {\n                this.adapter.log.error(error);\n              });\n          }\n          this.adapter.setState(path + \".\" + key, element[key], true);\n        }\n      }\n    } catch (error) {\n      this.adapter.log.error(\"Error extract keys: \" + path + \" \" + JSON.stringify(element));\n      this.adapter.log.error(error);\n    }\n  }\n  async extractArray(\n    element: any,\n    key: string,\n    path: string,\n    options?: {\n      [x: string]: any;\n      write: any;\n      channelName?: any;\n      autoCast?: any;\n      descriptions?: any;\n      preferedArrayName?: any;\n      forceIndex?: any;\n    },\n  ): Promise<void> {\n    try {\n      if (key) {\n        element = element[key];\n      }\n      for (let index in element) {\n        const arrayElement = element[index];\n        index = parseInt(index) + 1;\n        if (index < 10) {\n          index = \"0\" + index;\n        }\n        let arrayPath = key + index;\n        if (typeof arrayElement === \"string\") {\n          await this.parse(path + \".\" + key + \".\" + arrayElement, arrayElement, options);\n          continue;\n        }\n        if (typeof arrayElement[Object.keys(arrayElement)[0]] === \"string\") {\n          arrayPath = arrayElement[Object.keys(arrayElement)[0]];\n        }\n        for (const keyName of Object.keys(arrayElement)) {\n          if (keyName.endsWith(\"Id\") && arrayElement[keyName] !== null) {\n            if (arrayElement[keyName] && arrayElement[keyName].replace) {\n              arrayPath = arrayElement[keyName].replace(/\\./g, \"\");\n            } else {\n              arrayPath = arrayElement[keyName];\n            }\n          }\n        }\n        for (const keyName in Object.keys(arrayElement)) {\n          if (keyName.endsWith(\"Name\")) {\n            if (arrayElement[keyName] && arrayElement[keyName].replace) {\n              arrayPath = arrayElement[keyName].replace(/\\./g, \"\");\n            } else {\n              arrayPath = arrayElement[keyName];\n            }\n          }\n        }\n\n        if (arrayElement.id) {\n          if (arrayElement.id.replace) {\n            arrayPath = arrayElement.id.replace(/\\./g, \"\");\n          } else {\n            arrayPath = arrayElement.id;\n          }\n        }\n        if (arrayElement.name) {\n          arrayPath = arrayElement.name.replace(/\\./g, \"\");\n        }\n        if (arrayElement.label) {\n          arrayPath = arrayElement.label.replace(/\\./g, \"\");\n        }\n        if (arrayElement.labelText) {\n          arrayPath = arrayElement.labelText.replace(/\\./g, \"\");\n        }\n        if (arrayElement.start_date_time) {\n          arrayPath = arrayElement.start_date_time.replace(/\\./g, \"\");\n        }\n        if (options.preferedArrayName && options.preferedArrayName.indexOf(\"+\") !== -1) {\n          const preferedArrayNameArray = options.preferedArrayName.split(\"+\");\n          if (arrayElement[preferedArrayNameArray[0]]) {\n            const element0 = arrayElement[preferedArrayNameArray[0]].replace(/\\./g, \"\").replace(/\\ /g, \"\");\n            let element1 = \"\";\n            if (preferedArrayNameArray[1].indexOf(\"/\") !== -1) {\n              const subArray = preferedArrayNameArray[1].split(\"/\");\n              const subElement = arrayElement[subArray[0]];\n              if (subElement && subElement[subArray[1]] !== undefined) {\n                element1 = subElement[subArray[1]];\n              } else if (arrayElement[subArray[1]] !== undefined) {\n                element1 = arrayElement[subArray[1]];\n              }\n            } else {\n              element1 = arrayElement[preferedArrayNameArray[1]].replace(/\\./g, \"\").replace(/\\ /g, \"\");\n            }\n            arrayPath = element0 + \"-\" + element1;\n          }\n        } else if (options.preferedArrayName && options.preferedArrayName.indexOf(\"/\") !== -1) {\n          const preferedArrayNameArray = options.preferedArrayName.split(\"/\");\n          const subElement = arrayElement[preferedArrayNameArray[0]];\n          if (subElement) {\n            arrayPath = subElement[preferedArrayNameArray[1]].replace(/\\./g, \"\").replace(/\\ /g, \"\");\n          }\n        } else if (options.preferedArrayName && arrayElement[options.preferedArrayName]) {\n          arrayPath = arrayElement[options.preferedArrayName].replace(/\\./g, \"\");\n        }\n\n        if (options.forceIndex) {\n          arrayPath = key + index;\n        }\n        //special case array with 2 string objects\n        if (\n          !options.forceIndex &&\n          Object.keys(arrayElement).length === 2 &&\n          typeof Object.keys(arrayElement)[0] === \"string\" &&\n          typeof Object.keys(arrayElement)[1] === \"string\" &&\n          typeof arrayElement[Object.keys(arrayElement)[0]] !== \"object\" &&\n          typeof arrayElement[Object.keys(arrayElement)[1]] !== \"object\" &&\n          arrayElement[Object.keys(arrayElement)[0]] !== \"null\"\n        ) {\n          let subKey = arrayElement[Object.keys(arrayElement)[0]];\n          const subValue = arrayElement[Object.keys(arrayElement)[1]];\n          const subName = Object.keys(arrayElement)[0] + \" \" + Object.keys(arrayElement)[1];\n          if (key) {\n            subKey = key + \".\" + subKey;\n          }\n          if (!this.alreadyCreatedObjects[path + \".\" + subKey]) {\n            await this.adapter\n              .setObjectNotExistsAsync(path + \".\" + subKey, {\n                type: \"state\",\n                common: {\n                  name: subName,\n                  role: this.getRole(subValue, options.write),\n                  type: subValue !== null ? typeof subValue : \"mixed\",\n                  write: options.write,\n                  read: true,\n                },\n                native: {},\n              })\n              .then(() => {\n                // this.alreadyCreatedObjects[path + \".\" + subKey] = true;\n              });\n          }\n          this.adapter.setState(path + \".\" + subKey, subValue, true);\n          continue;\n        }\n        await this.parse(path + \".\" + arrayPath, arrayElement, options);\n      }\n    } catch (error) {\n      this.adapter.log.error(\"Cannot extract array \" + path);\n      this.adapter.log.error(error);\n    }\n  }\n  isJsonString(str: string): boolean {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  getRole(element: string, write: any): string {\n    if (typeof element === \"boolean\" && !write) {\n      return \"indicator\";\n    }\n    if (typeof element === \"boolean\" && write) {\n      return \"switch\";\n    }\n    if (typeof element === \"number\" && !write) {\n      return \"value\";\n    }\n    if (typeof element === \"number\" && write) {\n      return \"level\";\n    }\n    if (typeof element === \"string\") {\n      return \"text\";\n    }\n    return \"state\";\n  }\n}\n"],
  "mappings": "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",
  "names": ["JSONbig"]
}
